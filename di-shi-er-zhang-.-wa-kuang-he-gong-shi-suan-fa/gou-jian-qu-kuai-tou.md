# 构建区块头

构建区块头，挖矿节点需要填写六个字段，如表12-3所列。

表 12-3. 区块头结构

| 大小   | 字段                          | 描述                      |
| ---- | --------------------------- | ----------------------- |
| 4字节  | 版本(Version)                 | 一个多功能的位字段               |
| 32字节 | 前一区块哈希(Previous Block Hash) | 指向链中前一（父）区块的哈希的引用       |
| 32字节 | 默克尔根(Merkle Root)           | 这个区块交易的默克尔树的根节点哈希       |
| 4字节  | 时间戳(Timesteamp)             | 此区块的大致创建时间（自Unix纪元起的秒数） |
| 4字节  | 目标(Target)                  | 此区块的工作量证明算法目标           |
| 4字节  | 唯一随机数(Nonce)                | 一个用于工作量证明算法的计数器         |

\
版本字段最初是一个整数字段，并在比特币网络的三次升级中使用，这些升级定义在BIPs 34、66和65中。每次升级时，版本号都会递增。后来的升级将版本字段定义为位字段，称为versionbits，允许同时进行最多29个升级；详情请参阅“BIP9：信号和激活”第298页。更晚一些，矿工开始使用一些versionbits作为辅助随机数字段。

{% hint style="info" %}
BIPs 34、66和65中定义的协议升级是按照这个顺序依次发生的，BIP66（严格的DER）在BIP65（OP\_CHECKTIMELOCKVERIFY）之前发生，因此比特币开发人员通常按照这个顺序而不是按照数字顺序列出它们。
{% endhint %}

今天，versionbits字段没有意义，除非正在进行升级共识协议的尝试，在这种情况下，您将需要阅读其文档，以确定它如何使用versionbits。

接下来，挖矿节点需要添加“上一个区块哈希”（也称为prevhash）。这是来自网络的上一个块的块头哈希，Jing的节点已经接受并选择为他的候选块的父块。

{% hint style="info" %}
通过选择候选块头中的上一个区块哈希字段所指示的特定父区块，Jing将他的挖矿算力承诺到扩展以该特定区块结尾的链上。
{% endhint %}

下一步是使用默克尔树来承诺所有交易。每个交易都按拓扑顺序列出，使用其见证交易标识符（wtxid），其中32个0x00字节代表第一个交易（coinbase）的wtxid。正如我们在“Merkle Trees”中看到的，如果有奇数个wtxid，则最后一个wtxid将与自身哈希，创建每个包含一个交易哈希的节点。然后，交易哈希按成对组合，创建树的每个级别，直到所有交易被总结到树的“根”节点中。Merkle树的根将所有交易总结为一个单一的32字节值，即见证根哈希。

见证根哈希被添加到coinbase交易的输出中。如果块中的交易不需要包含见证结构，则可以跳过此步骤。然后，每个交易（包括coinbase交易）都使用其交易标识符（txid）进行列出，并用于构建第二个Merkle树，其根成为Merkle根，对其进行承诺到块头中。

Jing的挖矿节点然后添加一个4字节的时间戳，编码为Unix“纪元”时间戳，它是基于从1970年1月1日UTC/GMT午夜开始经过的秒数。

然后，Jing的节点填写nBits目标，它必须设置为使其成为有效块所需的PoW的紧凑表示。目标以“目标位”度量存储在块中，它是目标的尾数-指数编码。编码有一个字节的指数，后跟一个3字节的尾数（系数）。例如，在块277,316中，目标位值为0x1903a30c。第一部分0x19是十六进制指数，而下一部分0x03a30c是系数。目标的概念在“Retargeting to Adjust Difficulty”中解释，“目标位”表示在“Target Representation”中解释。

最后一个字段是随机数，初始化为零。

填写了所有其他字段后，候选块的头部现在已经完成，挖矿过程可以开始。目标现在是找到一个导致哈希小于目标的头部。挖矿节点将需要测试数十亿或数万亿个头部的变化，直到找到满足要求的版本。
