# 工作量证明算法(PoW)

哈希算法接受任意长度的数据输入，并产生一个固定长度的确定性结果，称为摘要。摘要是对输入的数字承诺。对于任何特定的输入，生成的摘要将始终相同，并且可以轻松地由实施相同哈希算法的任何人进行计算和验证。密码哈希算法的一个关键特征是，找到产生相同摘要的两个不同输入是计算上不可行的（称为碰撞）。作为推论，选择一种输入以产生所需的摘要也几乎是不可能的，除非尝试随机输入。&#x20;

使用SHA256，输出始终是256位长，而不考虑输入的大小。例如，我们将计算短语“Hello, World!”的SHA256哈希值：

```
$ echo "Hello, world!" | sha256sum
d9014c4624844aa5bac314773d6b689ad467fa4e1d1a50a1b8a99d5a95f72ff5 -
```

这个256位的输出（用十六进制表示）是该短语的哈希或摘要，并且依赖于短语的每个部分。添加一个字母、标点符号或任何其他字符将产生一个不同的哈希。&#x20;

在这种情况下使用的一个变量被称为 nonce。Nonce 用于改变密码函数的输出，这里用于改变 SHA256 对该短语的摘要输出。&#x20;

为了从这个算法中提出一个挑战，让我们设定一个目标：找到一个短语，它产生一个十六进制哈希，以零开头。幸运的是，这并不困难，如示例 12-4 所示。

示例 12-4. 简单的工作量证明实现

```
$ for nonce in $( seq 100 ) ; do echo "Hello, world! $nonce" | sha256sum ; done
3194835d60e85bf7f728f3e3f4e4e1f5c752398cbcc5c45e048e4dbcae6be782 -
bfa474bbe2d9626f578d7d8c3acc1b604ec4a7052b188453565a3c77df41b79e -
[...]
f75a100821c34c84395403afd1a8135f685ca69ccf4168e61a90e50f47552f61 -
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314 -
```

短语“Hello, World! 32”产生了以下哈希，符合我们的标准：09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314。找到它花费了32次尝试。从概率上讲，如果哈希函数的输出是均匀分布的，我们预计每16次哈希（从0到F的16个十六进制数字中的一个）就会找到一个以0开头的结果。用数字表示，这意味着找到的哈希值小于0x1000000000000000000000000000000000000000000000000000000000000000。我们将这个阈值称为目标，目标是找到一个数字上小于目标的哈希。如果我们降低目标，找到一个小于目标的哈希的任务就会变得越来越困难。

为了给出一个简单的类比，想象一场游戏，玩家反复投掷一对骰子，试图得到小于指定目标的点数。在第一轮中，目标是12。除非你掷出双6，否则你就赢了。在下一轮中，目标是11。玩家必须掷出10或更少的点才能赢，这又是一个容易的任务。假设几轮后，目标降到了5。现在，超过一半的骰子投掷将超过目标，因此无效。要赢得的次数越低，掷骰子的次数就越多。最终，当目标是2（可能的最小值）时，每36次投掷中只有一次，约占3%，会产生一个成功的结果。

从知道骰子游戏目标是3的观察者的角度来看，如果有人成功地进行了一次投掷，可以假设他们平均尝试了36次。换句话说，可以从目标所施加的困难来估计成功所需的工作量。当算法基于SHA256等确定性函数时，输入本身就构成了证明，证明了为了产生低于目标的结果所做的一定量工作。因此，工作量证明。

{% hint style="info" %}
尽管每次尝试都会产生随机结果，但任何可能结果的概率都可以事先计算。因此，指定难度的结果构成了特定工作量的证明。
{% endhint %}

在示例12-4中，获胜的“nonce”是32，这个结果可以由任何人独立确认。任何人都可以将数字32添加为短语“Hello, world!”的后缀并计算哈希，以验证其是否小于目标：

```
$ echo "Hello, world! 32" | sha256sum
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314 -
```

虽然验证只需一次哈希计算，但我们需要32次哈希计算才能找到有效的 nonce。如果我们有一个更低的目标（更高的难度），那么需要进行更多的哈希计算才能找到合适的 nonce，但任何人只需要一次哈希计算来验证。通过知道目标，任何人都可以利用统计数据估计难度，从而大致了解需要多少工作量才能找到这样的 nonce。

{% hint style="info" %}
工作量证明必须产生一个小于目标的哈希。更高的目标意味着更容易找到小于目标的哈希。更低的目标意味着更难找到小于目标的哈希。目标和难度是反相关的。
{% endhint %}

比特币的工作量证明与示例12-4中显示的挑战非常相似。矿工构建一个填充了交易的候选块。然后，矿工计算此块头的哈希，并查看其是否小于当前目标。如果哈希不小于目标，则矿工将修改 nonce（通常只是递增一个）并重试。在比特币网络的当前难度下，矿工必须尝试大量次数才能找到一个导致块头哈希低到足够的 nonce。
