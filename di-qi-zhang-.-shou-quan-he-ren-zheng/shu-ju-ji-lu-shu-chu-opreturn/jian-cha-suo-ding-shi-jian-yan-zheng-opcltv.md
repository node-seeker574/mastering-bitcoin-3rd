# 检查锁定时间验证（OP\_CLTV）

2015年12月，一种新形式的时间锁被引入比特币作为软分叉升级。根据BIP65规范，新增了一个名为OP\_CHECK LOCKTIMEVERIFY（OP\_CLTV）的脚本操作符。OP\_CLTV是一种基于输出的时间锁，而不是基于交易的时间锁，这与锁定时间不同。这样做可以增加时间锁的应用灵活性。

简单来说，通过在输出中使用OP\_CLTV操作码，该输出受限制，只能在指定的时间过去后才能花费。

OP\_CLTV并不取代锁定时间，而是限制特定的UTXO，使它们只能在具有设置为大于或等于指定值的锁定时间的未来交易中花费。

\
OP\_CLTV操作码接受一个参数作为输入，以与锁定时间相同的格式表示（可以是区块高度或Unix纪元时间）。如同VERIFY后缀所示，OP\_CLTV是一种如果结果为FALSE就会停止脚本执行的类型的操作码。如果结果为TRUE，则继续执行。

要使用OP\_CLTV，您需要将其插入到创建输出的交易中输出的赎回脚本中。例如，如果Alice要支付Bob，他可能通常会接受以下P2SH脚本支付：

\
\<Bob's public key> OP\_CHECKSIG

为了将其锁定到一个时间，比如说从现在开始的3个月后，他的P2SH脚本将改为：

\<Bob's pubkey> OP\_CHECKSIGVERIFY \<now + 3 months> OP\_CHECKLOCKTIMEVERIFY

其中 \<now + 3 months> 是一个块高度或时间值，从交易被挖掘时起预计的3个月后的值：当前块高度 + 12,960（块）或当前 Unix 时间 + 7,760,000（秒）。

当 Bob 尝试花费这个 UTXO 时，他构造一个引用该 UTXO 作为输入的交易。他在该输入的输入脚本中使用他的签名和公钥，并将交易锁定时间设置为等于或大于 Alice 设置的 OP\_CHECKLOCKTIMEVERIFY 的 timelock。然后 Bob 将交易广播到比特币网络。&#x20;

Bob 的交易如下评估。如果 Alice 设置的 OP\_CHECKLOCKTIMEVERIFY 参数小于或等于花费交易的锁定时间，则脚本继续执行（就好像执行了无操作或 OP\_NOP 操作码一样）。否则，脚本执行停止，并且交易被视为无效。&#x20;

更确切地说，BIP65 解释了如果发生以下情况，OP\_CHECKLOCKTIMEVERIFY 将失败并停止执行：&#x20;

• 栈为空。&#x20;

• 栈顶项小于 0。&#x20;

• 栈顶项的锁定时间类型（高度与时间戳）与锁定时间字段不相同。&#x20;

• 栈顶项大于交易的锁定时间字段。&#x20;

• 输入的序列字段为 0xffffffff。

\
