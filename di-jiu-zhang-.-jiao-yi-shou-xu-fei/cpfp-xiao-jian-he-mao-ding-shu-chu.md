# CPFP削减和锚定输出

在2018年，LN的开发人员遇到了一个问题。他们的协议使用需要两个不同方的签名的交易。双方都不愿意信任对方，因此他们在协议中不需要信任的点上签署交易，允许他们两者之一在以后的某个时间广播其中一个交易，而另一方可能不想要（或无法）履行其义务。这种方法的问题在于，这些交易可能需要在未来的某个不确定的时间广播，超出了任何合理的能力来估算这些交易的适当费率。

理论上，开发人员可以设计他们的交易以允许使用RBF（使用特殊的sighash标志）或CPFP进行费率提升，但这两种协议都容易受到交易固定的影响。鉴于所涉及的交易是时间敏感的，允许交易对手使用交易固定来延迟交易确认很容易导致一种可重复利用的利用方法，恶意方可能会用来从诚实方那里窃取钱财。

LN开发人员Matt Corallo提出了一个解决方案：给予CPFP费率提升规则一个特殊的例外，称为CPFP削减。CPFP的正常规则禁止在以下情况下包含额外的后代：如果这将导致一个父事务有26个或更多的后代，或者如果这将导致一个父事务及其所有后代总共超过100,000个vbytes。根据CPFP削减的规则，即使这将超出其他限制，也可以将大小不超过1,000个vbytes的单个额外交易添加到一个包中，只要它是一个没有未确认祖先的未确认交易的直接后代。

例如，Bob和Mallory共同签署了一个具有两个输出的交易，一个输出分别给他们两个人。Mallory广播了该交易，并使用她的输出附加了25个子交易或等于100,000个vbytes大小的任何较小数量的子交易。如果没有削减，Bob将无法为他的输出附加另一个子交易以进行CPFP费率提升。有了削减，只要他的子交易的大小不超过1,000个vbytes（这应该是足够的空间），他就可以花费交易中的两个输出之一，即属于他的输出。

不允许多次使用CPFP削减，因此它只适用于双方协议。已经有提议将其扩展到涉及更多参与者的协议，但对此并没有太多的需求，开发人员正在专注于构建更通用的解决方案来对抗交易固定攻击。

截至目前，大多数流行的LN实现使用一种称为锚定输出的交易模板，该模板设计用于与CPFP削减一起使用。
