# 交易固定

虽然我们描述的基本情况下RBF和CPFP费率提升都能正常工作，但与这两种方法相关的规则旨在防止对矿工和中继完整节点的拒绝服务攻击。这些规则的一个不幸副作用是它们有时会阻止某人能够使用费率提升。使得无法或难以对交易进行费率提升被称为_**交易固定**_。

一个主要的拒绝服务问题围绕着交易关系的影响。每当交易的输出被花费时，该交易的标识符（txid）将被子交易引用。然而，当一个交易被替换时，替换交易具有不同的txid。如果替换交易得到确认，则其后代不能包含在同一区块链中。重新创建和重新签名后代交易是可能的，但这并不保证会发生。这对RBF和CPFP有相关但不同的影响：

* 在RBF的情况下，当比特币核心接受替换交易时，通过忘记原始交易及所有依赖于该原始交易的后代交易，简化了事务处理。为了确保矿工接受替换交易更加有利可图，比特币核心只有在替换交易支付的费用高于将被遗忘的所有交易的费用时才接受替换交易。这种方法的缺点是，Alice可以创建一个支付给Bob的小交易。然后Bob可以使用他的输出来创建一个大的子交易。如果Alice想要替换她的原始交易，她需要支付的费用要比她和Bob最初支付的费用都要高。例如，如果Alice的原始交易大约为100个vbytes，Bob的交易大约为100,000个vbytes，并且他们都使用相同的费率，那么Alice现在需要支付比她最初支付的费用多1000多倍才能通过RBF提升她的交易费率。
* 在CPFP的情况下，每当节点考虑将一个事务包含在一个区块中时，它必须从它想要考虑的任何其他事务包中移除该事务包中的交易。例如，如果一个子交易支付给25个祖先，并且每个祖先有25个其他子代，那么在区块中包含该事务包需要更新大约625个事务包（25的平方）。类似地，如果从节点的内存池中移除一个具有25个后代的交易（例如被包含在一个区块中），并且每个后代都有25个其他祖先，则需要更新另外625个事务包。每次我们将参数加倍（例如，从25增加到50），我们的节点需要执行的工作量就增加了四倍。

&#x20;      此外，如果某个交易及其所有后代的替代版本被挖掘出来，将这个交易及其后代长期保留在内存池中是没有用的——除非发生罕见的区块链重新组织，否则这些交易都无法被确认。比特币核心将从其内存池中删除每个无法在当前区块链上确认的交易。在最坏的情况下，这可能会浪费大量节点的带宽，并可能被用来阻止交易正确传播。

&#x20;       为了防止这些问题以及其他相关问题，比特币核心限制了父交易在其内存池中最多具有25个     祖先或后代，并将所有这些交易的总大小限制为100,000 vbytes。这种方法的缺点是，如果一个交易已经有太多的后代（或者它及其后代太大），用户将无法创建CPFP费率提升。

\
交易固定可能是意外发生的，但它也代表了诸如LN等多方时间敏感协议的严重漏洞。如果您的交易对手可以通过截止日期阻止您的某个交易确认，他们可能会从您那里窃取钱财。

协议开发人员多年来一直致力于减轻交易固定问题。其中一个部分解决方案在第213页的“CPFP Carve Out and Anchor Outputs”中描述。还提出了几种其他解决方案，截至目前，至少有一个解决方案正在积极开发中——短暂锚点。
