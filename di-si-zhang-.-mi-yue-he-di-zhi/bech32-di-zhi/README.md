# Bech32地址

2017年，比特币协议进行了升级。当使用该升级时，它可以防止交易标识符（txids）在未经付款用户（或在需要多个签名时的签名者群体）的同意下被更改。该升级被称为隔离见证（简称segwit），还为区块中的交易数据提供了额外的容量以及其他几项好处。然而，想要直接获得segwit好处的用户必须接受新输出脚本的支付。

正如在“支付到脚本哈希”中提到的那样，P2SH输出类型的一个优点是支付者（比如Alice）不需要知道接收者（比如Bob）使用的脚本的详细信息。隔离见证升级旨在利用这种机制，允许用户立即开始通过使用P2SH地址来访问许多新的好处。但是，要让Bob获得所有的好处，他需要Alice的钱包使用不同类型的脚本支付给他。这需要Alice的钱包进行升级，以支持新的脚本。

起初，比特币开发人员提出了BIP142，它将继续使用base58check，但带有一个新的版本字节，类似于P2SH的升级。但是，让所有钱包升级到具有新base58check版本的新脚本预计将需要几乎与让它们升级到全新地址格式一样多的工作量，因此几位比特币贡献者着手设计最佳可能的地址格式。他们确定了base58check存在的几个问题：

* 其大小写混合的表示形式使得朗读或转录时不方便。试着向一位朋友朗读本章中的某个传统地址，让他们把它记录下来。注意到你不得不在每个字母前面加上“大写”和“小写”这样的词语。此外，请注意当你审阅他们写下的内容时，一些字母的大写和小写版本在许多人的手写中可能看起来相似。
* 可以检测错误，但无法帮助用户纠正这些错误。例如，如果你在手动输入地址时意外地交换了两个字符的位置，你的钱包几乎肯定会警告存在错误，但它不会帮助你找出错误出现在哪里。你可能需要花费几分钟才能最终发现错误。
* 使用大小写混合字母表还需要额外的空间来在QR码中进行编码，而QR码通常用于在钱包之间分享地址和发票。这额外的空间意味着在相同分辨率下，QR码需要更大才能被快速扫描。

在开发segwit地址格式的开发人员找到了一种新的地址格式，称为bech32（发音为软“ch”，如“besh thirty-two”）。 “bech”代表BCH，是三位于1959年和1960年发现bech32基于的循环码的缩写人物的首字母。 “32”代表bech32字母表中的字符数（类似于base58check中的58）：

* Bech32仅使用数字和一种大小写字母（最好以小写字母呈现）。尽管其字母表几乎是base58check字母表的一半大小，但用于付款给见证公钥哈希（P2WPKH）脚本的bech32地址只比等效的P2PKH脚本的传统地址稍长。
* Bech32既能检测错误，也能帮助纠正错误。在长度符合预期的地址中，它在数学上保证可以检测到影响四个字符或更少的任何错误；这比base58check更可靠。对于更长的错误，它将不会在十亿次操作中检测到它们的出现，这大致与base58check的可靠性相同。更重要的是，对于仅有少量错误的地址，它可以告诉用户错误发生的位置，使他们能够快速纠正轻微的抄录错误。示例4-3显示了输入有错误的地址的示例。

示例4-3。Bech32错别字检测

&#x20;地址：

&#x20;bc1p9nh05ha8wrljf7ru236aw~~**n**~~4t2x0d5ctkkywm~~**v**~~9sclnm4t0av2vgs4k3au7&#x20;

检测到的错误以粗体和删除线显示。使用bech32地址解码器演示生成。

* Bech32最好只用小写字母书写，但在将地址编码成QR码之前，这些小写字母可以被大写字母替换。这样可以使用一种特殊的QR编码模式，从而占用更少的空间。注意图4-9中相同地址的两个QR码的大小和复杂度的差异。



<figure><img src="../../.gitbook/assets/4.9.png" alt=""><figcaption><p>图 4-9.  相同的Bech32地址，一个使用小写字母编码，另一个使用大写字母编码</p></figcaption></figure>

* Bech32利用了SegWit设计的一种升级机制，使得支付者钱包能够支付尚未使用的输出类型。其目标是允许开发者构建一个钱包，使其能够在今天支付到Bech32地址，并且该钱包仍然能够支付给未来协议升级中添加的新功能的Bech32地址的用户。人们希望再也不需要经历系统范围的升级周期，以使人们能够完全使用P2SH和SegWit。

