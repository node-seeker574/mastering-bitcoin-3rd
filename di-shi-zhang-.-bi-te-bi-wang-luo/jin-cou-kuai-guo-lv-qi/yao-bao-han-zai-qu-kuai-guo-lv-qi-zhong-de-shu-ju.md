# 要包含在区块过滤器中的数据

\
我们的主要目标是允许钱包确定一个区块是否包含影响该钱包的交易。为了使钱包更有效，它需要了解两种类型的信息：

1. 当它收到钱时

&#x20;     具体来说，当一个交易输出包含钱包控制的脚本（例如通过控制授权的私钥）时。

2. 当它花费钱时

&#x20;      具体来说，当一个交易输入引用钱包控制的先前交易输出时。

&#x20;在设计紧凑型区块过滤器时的一个次要目标是允许接收过滤器的钱包验证它是否从对等方接收到准确的过滤器。例如，如果钱包下载了生成过滤器的区块，那么它可以生成自己的过滤器。然后，它可以将自己的过滤器与对等方的过滤器进行比较，并验证它们是否相同，从而证明对等方生成了准确的过滤器。&#x20;

为了实现主要目标和次要目标，过滤器需要引用两种类型的信息：

* 每个区块中每个交易输出的脚本。
* 每个区块中每个交易输入的引用点。&#x20;

紧凑型区块过滤器的早期设计包含了这两种信息，但后来意识到，如果我们牺牲次要目标，就可以更有效地实现主要目标。在新设计中，区块过滤器仍然引用两种类型的信息，但它们会更加相关：

* 与之前相同，每个区块中每个交易输出的脚本。
* 在更改中，它还将引用每个区块中每个交易输入引用的输出脚本。换句话说，正在花费的输出脚本。&#x20;

这有几个优点。首先，这意味着钱包不需要跟踪引用点；它们可以只扫描它们期望收到资金的输出脚本。其次，任何时候一个区块中的后续交易花费了同一个区块中较早交易的输出，它们都将引用相同的输出脚本。在紧凑型区块过滤器中，对同一个输出脚本的多次引用是多余的，因此可以删除多余的副本，从而缩小过滤器的大小。&#x20;

当全节点验证一个区块时，它们需要访问该区块中当前交易输出和被引用的先前区块中的交易输出的输出脚本，以便能够在这个简化模型中构建紧凑型区块过滤器。但是，一个区块本身不包含之前区块中的交易输出的输出脚本，因此没有方便的方式让客户端验证区块过滤器是否正确构建。然而，有一种替代方法可以帮助客户端检测对等方是否在说谎：从多个对等方获取相同的过滤器
